#include <WiFi.h>
#include <PubSubClient.h>

/*
This example demonstrates how to integrate the CPDev runtime (virtual machine, VM) into an ESP32 project.
The control program executed by the VM is stored in the ESP32â€™s flash memory using the LittleFS filesystem.
Two key files generated by CPDev - .xcp and .dcp - are stored on the board and can be uploaded easily without needing to recompile the whole firmware.
A convenient Arduino IDE plugin is available to upload these XCP and DCP files to the board: LittleFS Upload Plugin.
Alternatively, you may skip LittleFS and use USE_C_XCP constant to embed the example control program as a C byte table. 
Additionally, the example illustrates how to use FreeRTOS to run two tasks simultaneously:
the CPDev VM operates as a FreeRTOS task, while MQTT communication is handled via the standard loop() function.

Please provide the following before running the project:
- GPIO pins for the LEDs and a button
- WiFi network data
- IP address of a MQTT server
*/

// Uses LittleFS filesystem to store XCP and DCP files
#define USE_LITTLEFS

// Use XCP converted to a C table instead of a filesystem
#ifndef USE_LITTLEFS
//#define USE_C_XCP
#endif 

// Adjust to the maximum XCP size
#define XCP_MAXSIZE 2048

// Adjust if you have stack canary exception
#define TASK_STACK_SIZE 2000

#ifdef USE_LITTLEFS
#include "LittleFS.h"
#endif

#include "src/vm_arduino.h"
#include "src/vm_variable.h"

#ifdef USE_C_XCP
#include "data/WeJeStSt.c"
#endif

#define LED1PIN   3 // LED_BUILTIN
#define LED2PIN   4 // LED_BUILTIN
#define LED3PIN   5 // LED_BUILTIN
#define BUTTONPIN 6

VMArduino cpdev;
VMDCP dcpInfo;
VMVariable *out0, *out1, *out2, *out3, *onof;

WM_BYTE output;
WM_BYTE button = 1;

const char* ssid = "*******";
const char* password = "*******";

// Add your MQTT Broker IP address, example:
const char* mqtt_server = "192.168.31.15";

WiFiClient espClient;
PubSubClient client(espClient);
long lastMsg = 0;

void setup() {

  Serial.begin(115200);
  while(!Serial);

  Serial.println("CPDev test");

#ifdef USE_C_XCP
  if (cpdev.VMP_LoadProgramFromArray(WeJeStSt_xcp, DEFAULT_DATA_SIZE) != 0)    // note that SD library supports short (8+3) filenames only
#else

  if(!LittleFS.begin(true)){
    Serial.println("An error has occurred while mounting FS");
    return;
  }

  File file = LittleFS.open("/WeJeStSt.xcp", "r");
  if(!file){
    Serial.println("Failed to open XCP for reading");
    return;
  }

  static uint8_t buf[XCP_MAXSIZE];
  size_t len = file.size();

  if (len > XCP_MAXSIZE)
  {
    Serial.print("XCP is too large !");
    while (1);
  }
  
  file.read(buf, file.size());
  file.close();
  
  if (cpdev.VMP_LoadProgramFromArray(buf, DEFAULT_DATA_SIZE) != 0)
 
#endif  
  {
    Serial.print("Cannot load program into VM");
    while (1);
  }

#ifdef USE_LITTLEFS

  File fileDCP = LittleFS.open("/WeJeStSt.dcp");
  if(!fileDCP){
    Serial.println("Failed to open DCP for reading");
    return;
  }
  
  if (!dcpInfo.Load(fileDCP))
  {
    Serial.println("DCP ok");
    out0 = dcpInfo.InitVariable("OUT0"); 
    out1 = dcpInfo.InitVariable("OUT1");
    out2 = dcpInfo.InitVariable("OUT2");
    out3 = dcpInfo.InitVariable("OUT3");
    onof = dcpInfo.InitVariable("ONOF");
  }
  else
  {
    Serial.println("Cannot load DCP ");
    while (1);
  }
#else
    out0 = new VMVariable("OUT0", 0, 1); 
    out1 = new VMVariable("OUT1", 1, 1);
    out2 = new VMVariable("OUT2", 2, 1);
    out3 = new VMVariable("OUT3", 3, 1);
    onof = new VMVariable("ONOF", 4, 1);  
#endif 

  pinMode(BUTTONPIN, INPUT_PULLUP);

  pinMode(LED1PIN, OUTPUT);  
  pinMode(LED2PIN, OUTPUT);
  pinMode(LED3PIN, OUTPUT);

  xTaskCreate(
    cpdev_task,    // Function that should be called
    "CPDev task",   // Name of the task (for debugging)
    TASK_STACK_SIZE,            // Stack size (bytes)
    NULL,            // Parameter to pass
    1,               // Task priority
    NULL             // Task handle
  );

  setup_wifi();
  client.setServer(mqtt_server, 1883);
  client.setCallback(callback);

}

void loop() {

  if (!client.connected())
  {
    reconnect();
  }

  WM_BYTE out;
  long now = millis();

  if (now - lastMsg > 1000) {
    lastMsg = now;
       
    char tempString[8];
    cpdev.WM_GetData(out0, &out);
    client.publish("cpdev/out0", out ? "1" : "0");
    cpdev.WM_GetData(out1, &out);
    client.publish("cpdev/out1", out ? "1" : "0");
    cpdev.WM_GetData(out2, &out);
    client.publish("cpdev/out2", out ? "1" : "0");
    cpdev.WM_GetData(out3, &out);
    client.publish("cpdev/out3", out ? "1" : "0");
   
    client.publish("cpdev/in0", button ? "on" : "off");
  }    

  client.loop();

}

void cpdev_task(void * parameter)
{
  
  Serial.println("VM initializing...");
  cpdev.task_cycle = 100;
  cpdev.WM_Initialize(WM_MODE_FIRST_START | WM_MODE_NORMAL);


  while (cpdev.bRunMode)
  {
    //button = digitalRead(BUTTONPIN);  // set to 1 if you dont have a pushbutton
    cpdev.WM_SetData(onof,&button);
    
    cpdev.WM_RunCycle();

    cpdev.WM_GetData(out0, &output);
    digitalWrite(LED1PIN, output); 
    cpdev.WM_GetData(out1, &output);
    digitalWrite(LED2PIN, output);
    cpdev.WM_GetData(out2, &output);
    digitalWrite(LED3PIN, output);
    cpdev.WM_GetData(out3, &output);

    if (output)
    {
      digitalWrite(LED1PIN, output); 
      digitalWrite(LED2PIN, output); 
      digitalWrite(LED3PIN, output);
    } 
    
    //button = 0; // simulate button depressed
  }
  
  cpdev.WM_Shutdown(); 
    
  /* delete a task when finish,
    this will never happen because this is infinity loop */
  vTaskDelete( NULL );
}


void setup_wifi() {
  delay(10);
  // We start by connecting to a WiFi network
  Serial.println();
  Serial.print("Connecting to ");
  Serial.println(ssid);

  WiFi.begin(ssid, password);

  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }

  Serial.println("");
  Serial.println("WiFi connected");
  Serial.println("IP address: ");
  Serial.println(WiFi.localIP());
}

void callback(char* topic, byte* message, unsigned int length) {
  Serial.print("Message arrived on topic: ");
  Serial.print(topic);
  Serial.print(". Message: ");
  String messageTemp;
  
  for (int i = 0; i < length; i++) {
    Serial.print((char)message[i]);
    messageTemp += (char)message[i];
  }
  Serial.println();

  // If a message is received on the topic esp32/output, you check if the message is either "on" or "off". 
  // Changes the output state according to the message

  //WM_BYTE in0; 

  if (String(topic) == "cpdev/in0")
   {
    Serial.print("Changing in0 to ");
    if(messageTemp == "on"){
      Serial.println("on");
      button = 1;
      //cpdev.WM_SetData(onof,&in0);
    }
    else if(messageTemp == "off")
    {
      Serial.println("off");
      button = 0;
      //cpdev.WM_SetData(onof,&in0);
    }
  }
}

void reconnect() {
  // Loop until we're reconnected
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    // Create a random client ID
    String clientId = "ESP32Client-";
    clientId += String(random(0xffff), HEX);
    // Attempt to connect
    if (client.connect(clientId.c_str())) {
      Serial.println("connected");
      // Once connected, publish an announcement...
      client.publish("outTopic", "hello world");
      // ... and resubscribe
      client.subscribe("cpdev/in0");
    } else {
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5 seconds");
      // Wait 5 seconds before retrying
      delay(5000);
    }
  }
}
